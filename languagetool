#!/usr/bin/env python

from argparse import ArgumentParser, Namespace
from dataclasses import dataclass
from enum import Enum, auto
from itertools import accumulate
from json import dump, loads
from os import linesep
from sys import stderr, stdin, stdout
from typing import Iterable, Iterator, Mapping, Optional, Sequence, Union, cast
from urllib.parse import quote
from urllib.request import HTTPError, Request

from std2.pickle import decode, encode
from std2.types import never
from std2.urllib import urlopen


@dataclass(frozen=True)
class _DataNode1:
    markup: str


@dataclass(frozen=True)
class _DataNode2:
    text: str


_Data = Sequence[Union[_DataNode1, _DataNode2]]


@dataclass(frozen=True)
class _Req:
    text: Optional[str]
    data: Optional[_Data]
    language: str = "auto"


@dataclass(frozen=True)
class _Lang:
    name: str


@dataclass(frozen=True)
class _Replacement:
    value: str


@dataclass(frozen=True)
class _Context:
    text: str
    offset: int
    length: int


@dataclass(frozen=True)
class _Match:
    message: str
    shortMessage: str
    offset: int
    length: int
    context: _Context
    replacements: Sequence[_Replacement]


@dataclass(frozen=True)
class _Resp:
    language: _Lang
    matches: Sequence[_Match]


@dataclass(frozen=True)
class _PrintMatch:
    row: int
    col_begin: int
    col_end: int
    text: str
    context: _Context
    reason: str
    replacements: Sequence[str]


class _PrintFmt(Enum):
    json = auto()
    pretty = auto()


def _parse_matches(text: str, matches: Iterable[_Match]) -> Iterator[_PrintMatch]:
    lengths = tuple(len(line) for line in text.splitlines(keepends=True))
    acc_l = tuple(accumulate(lengths))
    for match in matches:
        row = sum(l < match.offset for l in acc_l)
        col_begin = match.offset - sum(
            l for l, a in zip(lengths, acc_l) if a < match.offset
        )
        col_end = col_begin + match.length - 1

        match_text = text[match.offset : match.offset + match.length]
        replacements = tuple(r.value for r in match.replacements)
        reason = match.message or match.shortMessage

        yield _PrintMatch(
            row=row,
            col_begin=col_begin,
            col_end=col_end,
            text=match_text,
            context=match.context,
            reason=reason,
            replacements=replacements,
        )


def _pprn(match: _PrintMatch) -> str:
    just = 16

    def cont() -> Iterator[str]:
        idx = f"{match.row + 1}:{match.col_begin + 1}:{match.col_end + 1}"
        yield idx.ljust(just)
        yield match.text
        yield linesep

        ctx = match.context
        yield " " * just
        yield ctx.text
        yield linesep
        yield " " * just
        yield " " * ctx.offset
        yield "^" * ctx.length
        yield linesep

        yield " " * just
        yield match.reason
        yield linesep
        yield linesep

    return "".join(cont())


def _parse_args() -> Namespace:
    fmt = _PrintFmt.pretty.name if not stdin.isatty() else _PrintFmt.json.name
    parser = ArgumentParser()
    parser.add_argument("server")
    parser.add_argument(
        "-f",
        "--format",
        choices=tuple(p.name for p in _PrintFmt),
        default=fmt,
    )
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    text = stdin.read()
    fmt = _PrintFmt[args.format]

    url = f"{args.server}/v2/check"
    headers = {
        "Content-Type": " application/x-www-form-urlencoded",
        "Accept": "application/json",
    }
    form_data = _Req(text=text, data=None)

    data = "&".join(
        f"{key}={quote(val)}"
        for key, val in cast(Mapping[str, str], encode(form_data)).items()
        if val is not None
    ).encode()
    req = Request(url=url, headers=headers, data=data)

    try:
        with urlopen(req) as resp:
            reply = resp.read().decode()
    except HTTPError as e:
        print(e, file=stderr)
    else:
        json = loads(reply)
        linted: _Resp = decode(_Resp, json, strict=False)
        matches = _parse_matches(text, matches=linted.matches)

        if fmt is _PrintFmt.json:
            dump(
                encode(tuple(matches)),
                fp=stdout,
                check_circular=False,
                ensure_ascii=False,
            )
        elif fmt is _PrintFmt.pretty:
            for match in matches:
                print(_pprn(match))
                pass
        else:
            never(fmt)


main()
