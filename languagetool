#!/usr/bin/env python

from argparse import ArgumentParser, Namespace
from dataclasses import dataclass
from enum import Enum, auto
from itertools import accumulate
from json import dump, loads
from os import environ, linesep
from pathlib import Path
from shutil import which
from subprocess import DEVNULL, run
from sys import argv, path, stderr, stdin, stdout
from typing import Iterable, Iterator, Mapping, Optional, Sequence, Union, cast
from urllib.error import HTTPError, URLError
from urllib.parse import quote, urlparse, urlunparse
from urllib.request import Request


_XDG_DATA_HOME = environ.get("XDG_DATA_HOME")
_RT_DIR = (
    (Path(_XDG_DATA_HOME) if _XDG_DATA_HOME else Path().home() / ".local" / "share")
    / "languagetool_cli"
    / "runtime"
)
_RT_DIR.mkdir(parents=True, exist_ok=True)
path.append(str(_RT_DIR))


try:
    from std2.pickle import decode, encode
    from std2.types import never
    from std2.urllib import urlopen
except ImportError:
    _REQUIREMENTS = Path(__file__).resolve().parent / "requirements.txt"
    cmd = "pip3"
    if which(cmd):
        proc = run(
            (
                cmd,
                "install",
                "--upgrade",
                "--target",
                str(_RT_DIR),
                "--requirement",
                str(_REQUIREMENTS),
            ),
            cwd=_RT_DIR,
            stdin=DEVNULL,
            stdout=stderr,
        )
        if proc.returncode:
            exit(proc.returncode)
        else:
            proc = run(argv)
            exit(proc.returncode)
    else:
        raise


@dataclass(frozen=True)
class _DataNode1:
    markup: str


@dataclass(frozen=True)
class _DataNode2:
    text: str


_Data = Sequence[Union[_DataNode1, _DataNode2]]


@dataclass(frozen=True)
class _Req:
    text: Optional[str]
    data: Optional[_Data]
    language: str = "auto"


@dataclass(frozen=True)
class _Lang:
    name: str


@dataclass(frozen=True)
class _Replacement:
    value: str


@dataclass(frozen=True)
class _Context:
    text: str
    offset: int
    length: int


@dataclass(frozen=True)
class _Match:
    message: str
    shortMessage: str
    offset: int
    length: int
    context: _Context
    replacements: Sequence[_Replacement]


@dataclass(frozen=True)
class _Resp:
    language: _Lang
    matches: Sequence[_Match]


@dataclass(frozen=True)
class _PrintMatch:
    row: int
    col_begin: int
    col_end: int
    text: str
    context: _Context
    reason: str
    replacements: Sequence[str]


def _parse_matches(text: str, matches: Iterable[_Match]) -> Iterator[_PrintMatch]:
    lens = tuple(len(line) for line in text.splitlines(keepends=True))
    acc_l = tuple(accumulate(lens))
    l_acc_l = tuple(zip(lens, acc_l))

    for match in matches:
        row = sum(l < match.offset for l in acc_l)
        col_begin = match.offset - sum(l for l, a in l_acc_l if a < match.offset)
        col_end = col_begin + match.length - 1

        match_text = text[match.offset : match.offset + match.length]
        replacements = tuple(r.value for r in match.replacements)
        reason = match.message or match.shortMessage

        yield _PrintMatch(
            row=row,
            col_begin=col_begin,
            col_end=col_end,
            text=match_text,
            context=match.context,
            reason=reason,
            replacements=replacements,
        )


def _pprn(match: _PrintMatch) -> str:
    just = 16

    def cont() -> Iterator[str]:
        idx = f"{match.row + 1}:{match.col_begin + 1}:{match.col_end + 1}"
        yield idx.ljust(just)
        yield match.text
        yield linesep

        ctx = match.context
        yield " " * just
        yield ctx.text
        yield linesep
        yield " " * just
        yield " " * ctx.offset
        yield "^" * ctx.length
        yield linesep

        yield " " * just
        yield match.reason
        yield linesep
        yield linesep

    return "".join(cont())


class _PrintFmt(Enum):
    json = auto()
    pretty = auto()


def _parse_args() -> Namespace:
    parser = ArgumentParser()
    parser.add_argument("source", default="-")
    parser.add_argument("server")
    parser.add_argument(
        "-f",
        "--format",
        choices=tuple(f.name for f in _PrintFmt),
        default=_PrintFmt.pretty.name,
    )
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    try:
        text = stdin.read() if args.source == "-" else Path(args.source).read_text()
    except (FileNotFoundError, PermissionError) as e:
        print(e, file=stderr)
        exit(1)
    else:
        fmt = _PrintFmt[args.format]
        server = urlparse(args.server)
        url = urlunparse((server.scheme, server.netloc, "/v2/check", None, None, None))
        form_data = _Req(text=text, data=None)

        data = "&".join(
            f"{key}={quote(val)}"
            for key, val in cast(Mapping[str, str], encode(form_data)).items()
            if val is not None
        ).encode()
        req = Request(url=url, data=data)

        try:
            with urlopen(req) as resp:
                reply = resp.read().decode()
        except (URLError, HTTPError) as e:
            print(e, file=stderr)
            exit(1)
        else:
            json = loads(reply)
            linted: _Resp = decode(_Resp, json, strict=False)
            matches = _parse_matches(text, matches=linted.matches)

            if fmt is _PrintFmt.json:
                dump(
                    encode(tuple(matches)),
                    fp=stdout,
                    check_circular=False,
                    ensure_ascii=False,
                )
            elif fmt is _PrintFmt.pretty:
                for match in matches:
                    print(_pprn(match))
                    pass
            else:
                never(fmt)


try:
    main()
except BrokenPipeError:
    exit()
except KeyboardInterrupt:
    exit(130)
